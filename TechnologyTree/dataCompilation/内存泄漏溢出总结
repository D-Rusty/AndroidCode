Android 内存泄漏总结：
  Java内存分配策略：
    Java程序运行时的内存分配策略有三种，分别是静态分配，栈分配，堆分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区(方法区)，栈区和堆区

    静态存储区：主要存放静态数据，全局static数据和常量，这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在
    栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型，对象的引用）都在栈上创建，并在方法执行技术时这些局部变量所持有的内存将会自动被释放，
         因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限
    堆区：又称动态内存分配，通常就是指在程序运行时直接new出来的内存，也就是引用变量指向的内存地址块，这部分内存在不使用时将会由Java垃圾回收器来负责回收。

    栈与堆的区别：
        在方法体内定义的(局部变量) 一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的，堆内存用来存放所有由new创建的对象和数组，在堆中产生了一个数组
        或者对象后，还可以在栈中定义一个特殊的变量（引用），这个变量的取值等于数组或者对象在堆内存中的首地址

  内存泄漏：
    1. 无用对象（不在使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏
    2. Java内存泄漏的根本原因：长生命周期的对象持有短生命周期的引用就很有可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用
    而导致不能被回收，这就是Java中内存泄漏的发生场景。

    具体分为一下几类：
     1.静态集合类引起内存泄漏：
       1.1 像HashMap,Vector等的使用最容易出现内存泄漏，这些静态变量的生命周期和引用程序一致，它们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用
       1.2 当集合里面的对象属性被修改后，在调用remove()方法时不起作用
       1.3 Android 或 Java中 使用到的监听器没有及时释放
       1.4 各种连接没有断开，如数据库连接，网络连接，io连接
       1.5 内部类和外部模块的引用
       1.6 单例模式，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏

Android中常见的内存泄漏汇总：
  1.集合类泄漏
  2.单例造成的内存泄漏
  3.匿名内部类/非静态内部类和异步线程
    非静态内部类创建静态实例造成的内存泄漏
  4.匿名内部类
    android开发经常会继承实现Activity/Fragment/View,此时如果你使用了匿名类，并被异步线程持有了，如果没有任何措施这样一定会导致泄漏
  5.Handler造成的内存泄漏
    万一 Handler 发送的Message尚未被处理，则该Message及发送它的Handler对象将被线程MessageQueue一直持有
    推荐使用静态内部类 + WeakReference 这种方式
  6.线程泄露  

  在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。

  软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。

假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形：

   6. 尽量避免使用static成员变量
      如果成员变量被声明为static，那我们都知道其生命周期将与整个app进程生命周期一样

   7.避免override finaize
     1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是： 虚拟机调用GC的时间不确定 Finalize daemon线程被调度到的时间不确定
     2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是：含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。
     3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。
   8.资源未关闭造成的内存泄漏
     对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，
     否则这些资源将不会被回收，造成内存泄漏。
     一些不良代码造成的内存压力

   9.有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。
     比如： Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。 构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。

   10.解决办法
      1.对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity被外部长生命周期的对象引用而泄露。
      2.尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。
      3.对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：
        将内部类改为静态内部类，静态内部类中使用弱引用来引用外部类的成员变量
      4.Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable.
      5.在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用
        的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则，正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用
        ，应该在Activity销毁时及时关闭或者注销，保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。

内存溢出

Android关于OOM的解决方案
  一、OOM，内存溢出，也就是说内存占有量超过了VM所分配的最大
  二、出现OOM的原因
      加载对象过大，相应资源过多，来不及释放
  三、如何解决：
     1.在内存引用上做些处理，常用的有软引用、强化引用、弱引用
     2.在内存中加载图片时直接在内存中作处理，如边界压缩
     3.动态回收内存
     4.优化Dalvik虚拟机的堆内存分配
     5.自定义堆内存大小




























































