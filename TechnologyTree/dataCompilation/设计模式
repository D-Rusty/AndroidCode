1. 策略模式
    定义一个策略接口，不同的实现类提供不同的具体策略算法  ----策略模式是提供一个对象给调用者
2. 简单工厂模式
    定义一个用以创建单个产品对象的工厂，根据不同的条件生成不同产品的对象 ----通过输入条件获取不同的对象
3. 工厂模式
   将简单工厂模式的那个方法分开，不再是在工厂方法中根据标志位创建对象了。而是定义一个工厂接口，然后想创建几个不同类型的对象（即实现了同一接口的不同java类），就创建了几个不同类型的工厂
4. 抽象工厂模式
    针对于产品族而言，提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类
5. 装饰着模式
    着重于对类进行功能叠加，同一个类，进行叠加，所以总是需要用到super
    装饰者模式: 动态的将新功能附加到对象上。在对象功能扩展方面，它 比继承更有弹性。
6. 代理模式
    代理类就是对实体保存一个引用，同时也实现了实体一样的接口方法，这样，就可以替代实体了
7. 模板模式
    子类通过继承抽象类重写不同的方法来添加各自的行为
8. 适配器模式
     把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端
     分为(类适配，对象适配器)，对象适配器采取实现，类适配采取继承
9. 建造者模式( Builder )
      建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。
      其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。
      建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个"导演类"的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。
10.观察者模式
      定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者.
11.单例模式( Singleton )
      保证一个类仅有一个实例,并提供一个访问它的全局控制点.
12.命令模式( Command )
      将一个请求封装成为一个对象, 使可以用不同的请求对客户进行参数化